Пояснение к лабораторным (2+3)

Вторая и третья лабораторные работы совмещены в один проект.
     Реализован проект службы, которая наблюдает за директорией сервера.
 	В сервере хранятся 2 папки : Source и Target.
     Имеется также папка DefaultServer, которая является сервером по умолчанию.
	И 2 файла конфигураций JSON и XML.
	Эти 2 файла и файл валидации XSD имеют название configuration.	
	Также есть в наличии 2 парсера XmlParser и JsonParser, созданные в качестве отдельных классов.
	 Класс-атрибут ParsableAttribute отвечает за дополнительные свойства парсеров. С его помощью можно задавать псевдонимы некоторым классам, полям и свойствам. Эти псевдонимы будут использованы при парсинге в обоих парсерах.
	
Окунаемся глубже в работу проекта
	Наличие действительных путей в тегах <add> (App.config) желательно и даже обязательно, ибо без них не будет значений по умолчанию =(
	Итак сам парсинг:
* Метод T Parse<T>() каждого из классов парсеров извлекает в первую очередь корень документа, затем извлекает тег с таким же названием. После в выбранном теге происходит поиск тега с заданным именем, а далее вызов метода T ParseNode<T>(nodeSelected).

* T ParseNode<T>( nodeSelected) вызывается всегда в Runtime через рефлексию типов. Работа метода как в JsonParser, так и в XmlParser, заключается в создании объекта класса T с помощью Activator.CreateInstance() и вернуть его в оболочке object. Далее из nodeSelected извлечь все атрибуты и внутренние теги с обычным текстом (для XML) или же просто достать все внутренние объекты (для JSON) и снова через рефлексию присвоить полям значения, полученные из узла и его составляющей. 

* Если какая-то из составляющих является сложным тегом, то рекурсивно будет вызван метод T1 ParseNode<T1>(selectedChildNode) для данного узла, тоже через рефлексию. T1 является типом, содержащемся в типе T и парсящимся на текущем уровне вложенности. Затем будет возвращён объект класса T1 и проверен на совместимость с текущим полем класса T. Если их типы совпали, то производится присвоение возвращённого объекта этому полю и парсинг происходит дальше, в противном случае значение данного поля останется по умолчанию.

* Если же внутренность – обычный тег без атрибутов с текстом по середине (XML), либо же строка (JSON), то происходит простое присваивание содержимого тега (или строки) нужному полю, с обязательной конвертацией типа в необходимый. Если при конвертации произошла ошибка, то значение остаётся по умолчанию.	
	
     Во время работы службы, при перетаскивании XML или JSON файлов могут возникать соответствующие исключения, которые будут записаны в ErrorLog.txt и ValidationLog.txt.
	В приоритете XML, после JSON, и в конце списка уже App.config.
